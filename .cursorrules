You are an expert in TypeScript, Next.js (App Router), Redux, Tailwind CSS, Shadcn UI, Radix UI, Jest, and progressive web application (PWA) development.

Key Principles
Write clean, maintainable, and secure TypeScript code.
Prioritize progressive enhancement, accessibility, and error handling.
Use functional programming and declarative patterns; avoid classes.
Adhere to strict TypeScript configurations and security best practices.
Ensure optimal performance and maintainability.
Code Implementation Guidelines
General
Use functional components with TypeScript interfaces for props.
Use named exports for components and utilities.
Leverage strict TypeScript settings ("strict": true in tsconfig.json) for type safety.
Use descriptive and semantic variable, function, and component names.
Routing (App Router)
Follow Next.js file-based routing conventions with the App Router (/app directory).
Use layout.tsx files for shared layouts and page.tsx for individual pages.
Use dynamic segments ([id]) and handle edge cases for missing or invalid parameters gracefully.
Implement middleware in middleware.ts for authentication, localization, and rate-limiting.
Styling
Use Tailwind CSS for styling; avoid inline styles.
Use Shadcn UI and Radix UI components to build accessible and reusable UI patterns.
Structure class names using the cn() utility from Shadcn to manage conditional styling.
Apply consistent theming with CSS variables (:root) defined in a global stylesheet.
Ensure all UI components are accessible (WCAG 2.1 AA compliant).
State Management
Use Redux Toolkit for global state management:
Structure slices in a store/ directory.
Use createSlice for state definitions and reducers.
Keep selectors, actions, and reducers organized and documented.
Use Redux middleware for logging, error handling, and asynchronous logic (e.g., Redux Thunk).
Data Fetching
Use Next.js server components and fetch for data fetching.
Utilize generateStaticParams for dynamic routes with static generation.
Use error.tsx and global-error.tsx for error boundaries.
Optimize API calls with caching and revalidation (cache, revalidate options).
Testing
Write unit tests for components and utilities using Jest and React Testing Library.
Use jest.mock for mocking external dependencies.
Include accessibility tests for interactive components.
Ensure high coverage with critical components and edge cases.
Progressive Web App (PWA) Best Practices
Use Next.js's PWA plugin to enable service workers and caching.
Optimize images with next/image and WebP formats.
Implement lazy loading for non-critical components and images.
Include a manifest.json for PWA metadata and app installability.
Use next/script for third-party scripts, deferring non-critical scripts.
Error Handling and Security
Handle errors at every layer (UI, API, state management).
Use Zod for schema validation and sanitization.
Secure sensitive data in environment variables (process.env).
Use Next.js's headers configuration to enforce security headers (CSP, HSTS).
Avoid exposing sensitive information in client-side code.
Performance Optimization
Use React Server Components (RSC) where possible.
Enable dynamic imports for large non-critical modules.
Use Tailwind CSS's group and peer utilities to minimize re-renders.
Optimize Core Web Vitals (LCP, FID, CLS) through lazy loading, prefetching, and efficient layouts.
Accessibility
Use ARIA attributes with Radix UI and Shadcn components.
Implement keyboard navigation and focus management for interactive elements.
Use semantic HTML for better screen reader compatibility.
Project Structure
Follow a modular project structure:
javascript
Copy code
/app/
  /[dynamic-segment]/
    page.tsx
    layout.tsx
  /components/
    /ui/
  /redux/
  /utils/
/public/
/styles/
Document component usage and API endpoints thoroughly.